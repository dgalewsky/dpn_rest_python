#!/usr/bin/python

# imports
import os, py_compile, re
import time, datetime, requests # pip install requests
from enum import Enum
from plumbum import local, SshMachine  # pip install plumbum
import bagit  # pip install bagit
import uuid
from dpnclient import client, util
import dpn_rest_settings
import hashlib
import pprint
import requests
import subprocess, logging

logging.basicConfig(filename='dpn.log',level=logging.DEBUG)
logging.captureWarnings(True)

# globals
BRIDGE_HOST = 'duracloud.tdl.org'
BRIDGE_URL = 'https://' + BRIDGE_HOST
BRIDGE_SNAPSHOT_LOCATION = '/ebs/duracloud/bridge/content/snapshots'
BRIDGE_RESTORE_LOCATION = '/ebs/duracloud/bridge/content/restorations'
BRIDGE_TMP_LOCATION = '/ebs/duracloud/tmp'
BRIDGE_SSH_USER = 'ec2-user'
BRIDGE_TOMCAT_USER = 'tomcat'
BRIDGE_SSH_KEY = '/home/dan/bridge/ssh.pem'
#MY_DOWNLOAD_LOCATION = '/home/dan/bridge/bags'
MY_DOWNLOAD_LOCATION = '/home/tdr/bags'
SNAPSHOTS = []
RESTORES = []
obj_id = ""

# helper classes
class SNAPSHOT_STATUS(Enum):
    INITIALIZED = 1
    TRANSFERRING_FROM_DURACLOUD = 2
    WAITING_FOR_DPN = 3
    CLEANING_UP = 4
    SNAPSHOT_COMPLETE = 5
    FAILED_TO_TRANSFER_FROM_DURACLOUD = 6
    @classmethod
    def tostring(cls, val):
        for k, v in vars(cls).iteritems():
            if v == val:
                return k
    @classmethod
    def fromstring(cls, string):
        return getattr(cls, string.upper(), None) if string != None else None

class RESTORE_STATUS(Enum):
    INITIALIZED = 1
    WAITING_FOR_DPN = 2
    DPN_TRANSFER_COMPLETE = 3
    TRANSFERRING_TO_DURACLOUD = 4
    TRANSFER_TO_DURACLOUD_COMPLETE = 5
    VERIFYING_TRANSFERRED_CONTENT = 6
    CLEANING_UP = 7
    ERROR = 8
    RESTORATION_COMPLETE = 9
    @classmethod
    def tostring(cls, val):
        for k, v in vars(cls).iteritems():
            if v == val:
                return k
    @classmethod
    def fromstring(cls, string):
        return getattr(cls, string.upper(), None) if string != None else None

# helper methods
def compileMe():
    myFilename = os.path.basename(__file__)
    if myFilename.endswith(".py"):
        print ("Compiling " + myFilename + "... ")
        py_compile.compile(os.path.basename(__file__))
        print ("done!")

def _make_tag_file(bag_info_path, bag_info):
    headers = list(bag_info.keys())
    headers.sort()
    with open(bag_info_path, 'w') as f:
        for h in headers:
            if type(bag_info[h]) == list:
                for val in bag_info[h]:
                    f.write("%s: %s\n" % (h, val))
            else:
                txt = bag_info[h]
                # strip CR, LF and CRLF so they don't mess up the tag file
                txt = re.sub('\n|\r|(\r\n)', '', txt)
                f.write("%s: %s\n" % (h, txt))

def makeDPNBag(snapshotId):
    global obj_id

    print ("Making a DPN bag!")
    # define variables
    tar_filename = snapshotId + ".tar"
    bag_directory = MY_DOWNLOAD_LOCATION + "/" + snapshotId

    # Mint a new object ID
    obj_id = str(uuid.uuid4())

    # define local commands
    rm = local["rm"]
    mkdir = local["mkdir"]
    tar = local["tar"]
    du = local["du"]
    grep = local["grep"]
    cut = local["cut"]
    sync = local["sync"]
    # make sure extraction directory doesn't already exist
    rm["-rf", bag_directory]()
    # make extraction directory
    mkdir["-p", bag_directory]()
    # extract the tar
    tar["-xf", MY_DOWNLOAD_LOCATION + "/" + tar_filename, "-C", bag_directory]()
    # patch the partial BagIt bag created by the snapshot/bridge server to really turn it into a BagIt bag
    cwd=os.getcwd()
    os.chdir(bag_directory)
    txt = """BagIt-Version: 0.97\nTag-File-Character-Encoding: UTF-8\n"""
    with open("bagit.txt", "w") as bagit_file:
        bagit_file.write(txt)
    os.chdir(cwd)
    # make it into a DPN bag
    bag_info = {
                'Source-Organization': 'Texas Preservation Node',
                'Organization-Address': '101 E 21st St, Austin TX, 78721',
                'Contact-Name': 'Gad Krumholz',
                'Contact-Phone': '512-495-4418',
                'Contact-Email': 'gad.krumholz@austin.utexas.edu',
                'Bagging-Date': datetime.date.strftime(datetime.date.today(), "%Y-%m-%d"),
                'Bag-Size': '',
                'Bag-Group-Identifier': '',
                'Bag-Count': ''
                }
    bag = bagit.Bag(bag_directory) #, bag_info=bag_info, processes=1, checksum=["sha256"])
    bag.info = bag_info
    # create dpn-tags/dpn-info.txt
    dpn_tag_file_name = bag_directory + "/"+ "dpn-tags/dpn-info.txt"
    mkdir["-p", bag_directory + "/" + "dpn-tags"]()
    dpn_info = {
                'DPN-Object-ID': obj_id, # Unique ID generated by First Node.
                'Local-ID': tar_filename, # Local identifier from originating repository.
                'First-Node-Name': 'Texas Preservation Network', # Name of the first node or source repository
                'First-Node-Address': '101 E 21st St, Austin TX, 78721', #
                'First-Node-Contact-Name': 'Gad Krumholz', #
                'First-Node-Contact-Email': 'gad.krumholz@austin.utexas.edu', #
                'Version-Number': '1', # Sequential positive integer
                'Previous-Version-Object-ID': '', # Object-ID of previous version
                'First-Version-Object-ID': obj_id, # Object-ID of the first version of the item
                'Brightening-Object-ID': '', # DPN UUID
                'Rights-Object-ID': '', # Reference to DPN and repository agreements
                'Object-Type': 'data', # data | brightening | rights # Bags will be only one of these three types of objects.
                }
    _make_tag_file(dpn_tag_file_name, dpn_info)
    # create the bash pipe for getting the Bag-Size
    du_chain = du["-bsc", bag_directory] | grep["total"] | cut["-f1"]
    # force a sync on the fs to get its new size
    sync()
    # get the bag's size
    bag_size = du_chain()
    bag.info['Bag-Size'] = bag_size
    bag.save(processes=1, manifests=False)
    # re-tar the bag
    tar["-cf", MY_DOWNLOAD_LOCATION + "/" + obj_id + ".tar", "-C", bag_directory, "."]()
    # cleanup the extracted directory
    rm["-rf", bag_directory]()

    print ("Done making DPN bag!")
    print ("Path to DPN Bag: " + MY_DOWNLOAD_LOCATION + "/" + obj_id + ".tar")

def printSnapshotInfo(s, details, contents):
    print ("Snapshot: " + s.get("snapshotId"))
    print ("Description: " + s.get("description"))
    print ("Status: " + "[" + s.get("status") + "]")
    print ("SnapshotDate: " + time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(details.get("snapshotDate") / 1000)))
    print ("Source Space Id: " + details.get("sourceSpaceId"))
    print ("Total Size in Bytes: " + str(details.get("totalSizeInBytes")))
    print ("Source Store Id: " + details.get("sourceStoreId"))
    print ("Items[" + str(contents.get("totalCount")) + "]:")
    for c in contents.get("contentItems"):
        print ("\tItem: " + c.get("contentId"))
        print ("\t\tcontent-mimetype: " + str(c.get("contentProperties").get("content-mimetype")))
        print ("\t\tcontent-checksum: " + str(c.get("contentProperties").get("content-checksum")))
        print ("\t\tcontent-modified: " + str(c.get("contentProperties").get("content-modified")))
        print ("\t\tcontent-size: " + str(c.get("contentProperties").get("content-size")))
        print ("\t\tcreator: " + str(c.get("contentProperties").get("creator")))
        print ("\t\tcontent-file-created: " + str(c.get("contentProperties").get("content-file-created")))
        print ("\t\tcontent-file-path: " + str(c.get("contentProperties").get("content-file-path")))
        print ("\t\tcontent-file-modified: " + str(c.get("contentProperties").get("content-file-modified")))
        print ("\t\tcontent-file-last-accessed: " + str(c.get("contentProperties").get("content-file-last-accessed")))

# rest client methods
def getSnapshots():
    del SNAPSHOTS[:]

    url = BRIDGE_URL + '/bridge/snapshot'  # ? host=(host)
    params = dict(host=BRIDGE_HOST)
    resp = requests.get(url=url, params=params)
    for s in resp.json().get("snapshots"):
        details = getSnapshotDetails(s.get("snapshotId"))
        contents = getSnapshotContents(s.get("snapshotId"))
        SNAPSHOTS.append(dict(snapshot=s, details=details, contents=contents))

        printSnapshotInfo(s, details, contents)

def getSnapshotContents(snapshotId):
    url = BRIDGE_URL + '/bridge/snapshot/' + snapshotId + '/content'  # ? page=(pageNumber) & pageSize=(pageSize) & prefix=(prefix)'
    params = dict(prefix="")
    resp = requests.get(url=url, params=params)
    return resp.json()

def getSnapshotDetails(snapshotId):
    url = BRIDGE_URL + '/bridge/snapshot/' + snapshotId
    resp = requests.get(url=url)
    return resp.json()

def sendSnapshotComplete(snapshotId):
    url = BRIDGE_URL + '/bridge/snapshot/' + snapshotId + '/complete'
    resp = requests.post(url=url)
    return resp.json()

def getRestores():
    url = BRIDGE_URL + '/bridge/restore/by-snapshot'
    del RESTORES[:]
    for s in SNAPSHOTS:
        snapshotId = s.get("snapshot").get("snapshotId")
        myUrl = url + '/' + snapshotId
        restore = requests.get(url=myUrl).json()
        restoreId = restore.get("restoreId")
        status = RESTORE_STATUS.fromstring(restore.get("status"))
        if status == RESTORE_STATUS.WAITING_FOR_DPN:
            print ("Found restoration: ")
            print ("\tRestoreId: " + restoreId)
            snapshot_tar_filename = snapshotId + ".tar"
            bridge_restore_path = BRIDGE_RESTORE_LOCATION + "/" + restoreId
            remote = SshMachine(BRIDGE_HOST, user=BRIDGE_SSH_USER, keyfile=BRIDGE_SSH_KEY, ssh_opts = ["-tt"]) # needs a tty to use sudo
            r_tar = remote["tar"]
            r_sudo = remote["sudo"]
            r_rm = remote["rm"]
            # upload tar
            print ("\tscp'ing " + BRIDGE_SSH_USER + "@" + BRIDGE_HOST + ":" + MY_DOWNLOAD_LOCATION + "/" + snapshot_tar_filename + " " + BRIDGE_TMP_LOCATION)
            remote.upload(MY_DOWNLOAD_LOCATION + "/" + snapshot_tar_filename, BRIDGE_TMP_LOCATION)
            # extract tar
            print ("\tExtracting snapshot to restore directory: " + snapshot_tar_filename + " into dir: " + bridge_restore_path)
            r_sudo["-u", BRIDGE_TOMCAT_USER, r_tar["-xf", BRIDGE_TMP_LOCATION + "/" + snapshot_tar_filename, "-C", bridge_restore_path, "."]]()
            # cleanup tar
            r_rm["-rf", BRIDGE_TMP_LOCATION + "/" + snapshot_tar_filename]()
            # tell bridge we're done
            print ("\tTelling bridge we're done with restoration")
            sendRestoreComplete(restoreId)
            print ("\tDone restoring snapshot!")

def sendRestoreComplete(restoreId):
    url = BRIDGE_URL + '/bridge/restore/' + restoreId + '/complete'
    resp = requests.post(url=url)
    return resp.json()

# main methods of program
def ingestSnapshots():

    global bridge_snapshot_path

    getSnapshots()
    print ("Ingesting snapshots!")
    for s in SNAPSHOTS:
        status = SNAPSHOT_STATUS.fromstring(s.get("snapshot").get("status"))
        if status == SNAPSHOT_STATUS.WAITING_FOR_DPN:
            print ("Found a snapshot to grab!")
            snapshotId = s.get("snapshot").get("snapshotId")
            bridge_snapshot_path = BRIDGE_SNAPSHOT_LOCATION + '/' + snapshotId
            remote = SshMachine(BRIDGE_HOST, user=BRIDGE_SSH_USER, keyfile=BRIDGE_SSH_KEY)
            # remote make tar
            r_tar_filename = BRIDGE_TMP_LOCATION + "/" + snapshotId + ".tar"
            r_tar = remote["tar"]
            print ("\tTar'ing up snapshot directory: " + bridge_snapshot_path + " into tar: " + r_tar_filename)
            r_tar["-cf", r_tar_filename, "-C", bridge_snapshot_path, "."]()
            # download tar from remote
            print ("scp'ing " + BRIDGE_SSH_USER + "@" + BRIDGE_HOST + ":" + r_tar_filename + " " + MY_DOWNLOAD_LOCATION)
            remote.download(r_tar_filename, MY_DOWNLOAD_LOCATION)
            # cleanup remotely created tar
            print ("\tCleaning up remote tar file: " + r_tar_filename)
            r_rm = remote["rm"]
            r_rm["-rf", r_tar_filename]()

            # extract the tar, turn it into a DPN bag, and tar it back up
            makeDPNBag(snapshotId)

            # TODO: put it in TPN (stash it in iRODS)
            # TODO: tell DPN to come get it (make the DPN rest calls)
            # tell bridge we're done
            print ("\tNOT Telling bridge we're done with snapshot")

            #sendSnapshotComplete(snapshotId)

            print ("\tDone ingesting snapshot!")

def restoreSnapshots():
    print ("Restoring snapshots!")
    getSnapshots()
    getRestores()

def dpn_ingest():

    global obj_id, bridge_snapshot_path

    print("Obj Id " + obj_id)

    # Compute path to the bag
    obj_path = MY_DOWNLOAD_LOCATION + "/" + obj_id + ".tar"

    # Compute some info needed for the DPN bag record and transfer record
    file_size = os.path.getsize(obj_path)
    fixity = hashlib.sha256(open(obj_path, 'rb').read()).hexdigest()

    print("Fixity " + fixity + " file_size " + str(file_size))

    # Create a dpn-rest client

    myclient = client.Client(dpn_rest_settings, dpn_rest_settings.DEV)

    try:
        response = myclient.create_bag_entry(obj_id, 1024, 'D', fixity, bridge_snapshot_path )
    except Exception as ex:
        print("Error: " +  str(ex))
        sys.exit(0)

    # If all goes well - print the response.

    pprint.pprint(response)

    # Create a transfer

    try:
        # obj_id, bag_size, username, fixity
        response = myclient.create_transfer_request(obj_id, 1024, 'tdr', fixity)
    except Exception as ex:
        print("Error: " +  str(ex))
        sys.exit(0)

#    pprint.pprint(response)


def copy_bag_to_irods():
    global obj_id

    obj_path = MY_DOWNLOAD_LOCATION + "/" + obj_id + ".tar"
    print ("\nCopy bag to irods - path: " + obj_path)

    basename = os.path.basename(obj_path)

    print("Basename: " + basename)

    irods_dir = basename[0:2]

    print("Irods dir: " + irods_dir)

    # Set up output file

    opath = '/corralZ/home/tdl-utexas/tdr/' + irods_dir + "/" + basename
    print("Path " + opath)

    # Copy file to iRods
    ret = subprocess.check_output(["iput", obj_path, opath])

    print("Return from iput: " + str(ret))

# main program
compileMe()
ingestSnapshots()

copy_bag_to_irods()
dpn_ingest()

#restoreSnapshots()


